# -*- coding: utf-8 -*-
"""
Created on Tue Feb 11 11:34:57 2014

@author: hzhu
"""

from random import randint
import Image
import math

def build_random_function(min_depth, max_depth):
    """Creates random functions from the following required blocks:
        
        prod(a,b) = ab
        cos_pi(a) = cos(pi*a)
        sin_pi(a) = sin(pi*a)
        x(a,b) = a
        y(a,b) = b

        min_depth: minimum amount of nesting for the function that's generated
        max_depth: maximum amount of nesting of the function that's generated
    """
    # These if statements create a safety net for the boundaries of function choice.
    if max_depth == 1:
        fn_choice = randint(0,1)
    else:
        fn_choice = randint(0,4)
    if min_depth >= 2:
        fn_choice = randint(2,4)
    
    # Make a choice and use recursion to create the final output.
    if fn_choice == 0:
        return ['x']
    elif fn_choice == 1:
        return ['y']
    elif fn_choice == 2:
        return ['sin_pi', build_random_function(min_depth-1,max_depth-1)]
    elif fn_choice == 3:
        return ['cos_pi', build_random_function(min_depth-1,max_depth-1)]
    elif fn_choice == 4:
        return ['prod', build_random_function(min_depth-1,max_depth-1), build_random_function(min_depth-1,max_depth-1)]

def evaluate_random_function(f, x, y):
    """Evaluates the random functions generated by build_random_function. The output of this function is the value of the input function evaluated at the input (x,y) pair.

        f: random function to evaluate
        x: value of x to evaluate the function at
        y: value of y to evaluate the function at
    """
    # Create base cases and recursions for more complex functions.
    if f[0] == 'x':
        return x
    elif f[0] == 'y':
        return y
    elif f[0] == 'cos_pi':
        return math.cos(math.pi * evaluate_random_function(f[1],x,y))
    elif f[0] == 'sin_pi':
        return math.sin(math.pi * evaluate_random_function(f[1],x,y))
    elif f[0] == 'prod':
        return evaluate_random_function(f[1],x,y) * evaluate_random_function(f[2],x,y)

def remap_interval(val, input_interval_start, input_interval_end, output_interval_start, output_interval_end):
    """ Maps the input value that is in the interval [input_interval_start, input_interval_end] 
        to the output interval[output_interval_start, output_interval_end]. 
        The mapping is an affine one (i.e. output = input*c + b).
    """
    # Generates differences for ease of scaling.
    diff_in = float(input_interval_end) - float(input_interval_start)
    diff_out = float(output_interval_end) - float(output_interval_start)

    return (val - float(input_interval_start)) * diff_out/diff_in + output_interval_start

if __name__ == "__main__":
    # Customizable settings.
    min_depth = 5
    max_depth = 5  
    x_range = 1600
    y_range = 900
    im = Image.new("RGB",(x_range,y_range))

    # Declare color equations.
    red = build_random_function(min_depth, max_depth)
    green = build_random_function(min_depth, max_depth)
    blue = build_random_function(min_depth, max_depth)

    # Loop through each pixel.
    for i in range(x_range):
        for j in range(y_range):
            x = remap_interval(i,0,x_range-1,-1,1)
            y = remap_interval(j,0,y_range-1,-1,1)
            color_red = int(remap_interval(evaluate_random_function(red,x,y),-1,1,0,255))
            color_green = int(remap_interval(evaluate_random_function(green,x,y),-1,1,0,255))
            color_blue = int(remap_interval(evaluate_random_function(blue,x,y),-1,1,0,255))
            x = int(x)
            y = int(y)
            im.putpixel((i,j),(color_red,color_green,color_blue))

    # Save.
    # im.save(str(randint(0,100000))+'.bmp')
    im.save('wallpaper.bmp')